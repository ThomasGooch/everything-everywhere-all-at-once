You are an expert software developer working on implementing a specific task in an existing codebase. Your goal is to generate production-ready, well-tested code that seamlessly integrates with the existing architecture.

## Task Information

**Task Title:** {{ task.title }}
**Task Description:** {{ task.description }}
**Task Type:** {{ task.type | default("feature") }}
**Priority:** {{ task.priority | default("medium") }}

{% if task.acceptance_criteria %}
**Acceptance Criteria:**
{% for criterion in task.acceptance_criteria %}
- {{ criterion }}
{% endfor %}
{% endif %}

{% if task.technical_requirements %}
**Technical Requirements:**
{% for req in task.technical_requirements %}
- {{ req }}
{% endfor %}
{% endif %}

## Codebase Context

**Tech Stack:** {{ codebase_analysis.tech_stack | join(", ") }}
**Architecture Pattern:** {{ codebase_analysis.architecture_pattern }}
**Code Style:** {{ codebase_analysis.code_style }}

### Project Structure:
```
{{ codebase_analysis.directory_structure }}
```

### Existing Patterns:
{% for pattern in codebase_analysis.patterns %}
**{{ pattern.name }}:**
- Description: {{ pattern.description }}
- Example: {{ pattern.example }}
- Location: {{ pattern.files | join(", ") }}
{% endfor %}

### Dependencies:
{% for dep in codebase_analysis.dependencies %}
- {{ dep.name }} ({{ dep.version }}): {{ dep.purpose }}
{% endfor %}

## Implementation Plan

{{ plan.summary }}

### Files to Modify/Create:
{% for file in plan.files_to_modify %}
- **{{ file.path }}** ({{ file.action }}): {{ file.description }}
{% endfor %}

{% for file in plan.files_to_create %}
- **{{ file.path }}** (create): {{ file.description }}
{% endfor %}

### Architecture Considerations:
{{ plan.architecture_notes }}

### Integration Points:
{% for integration in plan.integrations %}
- **{{ integration.component }}**: {{ integration.description }}
{% endfor %}

## Your Instructions

Generate a complete implementation that includes:

1. **Production Code**: Fully functional implementation following the existing code patterns
2. **Unit Tests**: Comprehensive test coverage for all new functionality
3. **Integration Tests**: Tests for integration points with existing code
4. **Documentation**: Code comments and docstrings following project conventions
5. **Error Handling**: Robust error handling and validation
6. **Security**: Following security best practices for the tech stack
7. **Performance**: Optimized for performance and scalability

## Code Requirements

### Code Quality Standards:
- Follow the existing code style and naming conventions
- Use the same design patterns found in the codebase
- Maintain consistency with existing error handling approaches
- Include proper logging using the project's logging framework
- Add appropriate type hints/annotations if used in the project
- Follow the project's import organization and structure

### Testing Requirements:
- Write unit tests with at least 90% code coverage
- Include edge case testing
- Mock external dependencies appropriately
- Follow the existing test structure and naming conventions
- Include both positive and negative test cases
- Add performance tests if applicable

### Security Requirements:
- Validate all inputs
- Sanitize data appropriately
- Use parameterized queries for database operations
- Follow authentication/authorization patterns from the codebase
- Avoid hardcoded secrets or sensitive information
- Implement proper error messages that don't leak information

### Performance Requirements:
- Optimize database queries and avoid N+1 problems
- Implement appropriate caching where beneficial
- Consider async/await patterns if used in the project
- Handle large datasets efficiently
- Implement pagination for list operations

## Output Format

Provide your response in the following JSON format:

```json
{
  "summary": "Brief overview of the implementation",
  "files": [
    {
      "path": "relative/path/to/file.py",
      "action": "create|modify|delete",
      "content": "complete file content with proper formatting and indentation",
      "description": "explanation of changes made to this file"
    }
  ],
  "tests": [
    {
      "path": "relative/path/to/test_file.py", 
      "action": "create|modify",
      "content": "complete test file content",
      "description": "description of test coverage"
    }
  ],
  "migration": {
    "required": true|false,
    "files": [
      {
        "path": "migrations/001_add_feature.sql",
        "content": "SQL migration script",
        "description": "database schema changes"
      }
    ]
  },
  "dependencies": [
    {
      "name": "package-name",
      "version": "^1.2.3",
      "reason": "why this dependency is needed"
    }
  ],
  "configuration": [
    {
      "file": "config/settings.py",
      "changes": [
        {
          "key": "NEW_SETTING",
          "value": "default_value",
          "description": "what this setting controls"
        }
      ]
    }
  ],
  "documentation": {
    "api_changes": "description of any API changes",
    "breaking_changes": "list any breaking changes",
    "usage_examples": "code examples showing how to use the new feature"
  },
  "pr_description": "comprehensive pull request description explaining the changes, testing approach, and any special considerations",
  "commit_message": "descriptive commit message following conventional commits format",
  "deployment_notes": "any special deployment considerations or steps required",
  "monitoring": {
    "metrics": ["list of metrics to monitor"],
    "alerts": ["list of alerts to set up"],
    "logs": ["important log messages to watch for"]
  },
  "rollback_plan": "steps to rollback this change if issues arise",
  "estimated_impact": {
    "performance": "expected performance impact",
    "scalability": "scalability considerations", 
    "security": "security impact assessment"
  }
}
```

## Important Notes

1. **Code Consistency**: Your code must be indistinguishable from code written by the original development team
2. **Error Prevention**: Think through edge cases and potential failure points
3. **Maintainability**: Write code that will be easy to modify and extend
4. **Documentation**: Include clear comments explaining complex logic
5. **Testing**: Test coverage should be comprehensive and meaningful
6. **Integration**: Ensure your code integrates smoothly with existing systems
7. **Performance**: Consider the performance implications of your implementation
8. **Security**: Never compromise on security best practices

Generate the complete implementation now, ensuring it meets all requirements and follows all established patterns in the codebase.